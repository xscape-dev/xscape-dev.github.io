[{"content":"基本操作 \u0026amp;取址操作符 *取值操作符 数组名指向数组的第一个元素的地址。 不要解引用未初始化的指针 1. 初始化 如果数组未初始化，那么数组中的元素会使用“垃圾值”来填充。如果手动初始化了部分数组元素，那么剩余未初始化的元素会用类型的默认值来填充。 C语言不允许把数组作为一个单元赋值给另一个数组(可以使用指针)\nchar arr_1[5] = {\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;}; char arr_2[5]; arr_2 = arr_1; // 错误，不允许 char* arr_3 = arr_1; // 正确，允许 2. 数组边界 使用数组时，要防止数组下标超出边界，必须保证下标是有效值。C编译器一般不会检查数组下标越界的问题，也不会报错。\n在声明数组时使用符号常量来表示数组大小，以保证整个程序中的数组大小始终一致\n3. 指针和数组 一个数组名就是数组第一个元素的地址。即： char arr[4] = {\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;} arr == \u0026amp;arr[0]; // 或者 printf(\u0026#34;%p\u0026#34;,\u0026amp;arr); printf(\u0026#34;%p\u0026#34;,\u0026amp;arr[0]) // 打印的值一样 数组首元素的内存地址都是常量，在程序运行过程中不会被改变，但是可以将地址赋值给变量，然后再修改指针变量的值。 在系统中，地址按字节编址。short占两字节，double占四字节，在C中，指针加1指的是增加一个存储单元，而不是指向下一个字节。\n这是为什么必须声明指针所指向对象类型的原因之一，只知道地址是不够的，因为计算机要知道储存对象需要多少字节。\nshort类型指针+1，代表地址+2；double类型指针+1，代表地址+4；如果只知道地址而不知道变量类型，那么指针就无法正确获取元素的地址。\nC语言指针和数组的灵活性\narr+2 = \u0026amp;arr[2]; *(arr+2) = arr[2]; *(arr+2)的含义可以表述为：在内存arr的位置，移动2个单元，再获取储存在哪里的值\n函数、数组、指针 1. 指针形参 一个处理数组的函数，其形参应该是一个指向特定类型的指针。\n// 求数组中的元素之和 int sum(int* arr); sum函数获得了arr的地址，并以arr首元素的地址为起始地址查找一串整数。但是sum函数并不知道数组的元素个数，所以可以在第二个形参中，接受一个表示数组长度的参数。\nint sum(int* arr,int len); 如果形参要求是一个与数组相匹配的指针，那么下面这两种声明方式是等价的。\nint sum(int* arr, int len); int sum(int arr[], int len); 系统使用8字节存储地址，所以指针变量的大小是8字节。\n2. 使用指针形参 函数处理数组要知道何时开始、何时结束。\n另一种方法是，使用双指针，标记数组的其实和开始的位置。\nint sump(int* start, int* end) { int total = 0; while(start \u0026lt; end) { total+=*start; start++; } return total } // 调用 #define SIZE 10 int arr[SIZE] = { ... } sump(arr, arr + SIZE); 数组的下标从0开始，其中end = arr + SIZE，其指向数组末尾元素的下一个位置。所以不会产生数组越界问题。\n3. 指针表示法、数组表示法 处理数组的函数实际上是用指针作为参数的，但是在编写函数时，可以选择形参是以数组的形式表示还是指针的形式表示。\n4. 指针操作 解引用：*运算符给出指针指向地址上的存储的值。\n创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。\nint* ptr; *ptr = 5; // 错误 指针若只被创建但未初始化，其地址值是一个随机值，将5赋值给该指针，并不知道5存储在何处。\n注意：不要解引用未初始化的指针\n5. 保护数组中的数据 如果不希望在函数内部改变原始数据的值，需要在形参加上const关键字。此处的const的意思不是常量，而是表示函数在处理数组时将实参当错常量来处理，一旦代码试图对实参的数据进行修改，那么编译器会报编译错误。\nint sum(const int arr[],int n); const可用于创建const数组、const指针以及指向const的指针。\n","permalink":"https://xscape.dev/posts/c_array/","summary":"本文讲解了C语言中指针与数组的基础操作，讲解了取址、解引用、数组初始化规则及边界保护的重要性，并通过示例说明了指针形参、双指针和const关键字的应用，强调了避免解引用未初始化指针和保护数组数据的实用方法。","title":"C 语言：数组"},{"content":" 为什么选择 CSRedis 1.ServiceStack.Redis 是商业版，免费版有限制。 2.StackExchange.Redis 是免费版，但是内核在 .NET Core 运行有问题经常 Timeout，暂无法解决。 3.CSRedis 于 2016 年开始支持 .NET Core 一直迭代至今，实现了低门槛、高性能，和分区高级玩法。\n在 v3.0 版本更新中，CSRedis 中的所有方法名称进行了调整，使其和 redis-cli 保持一致，如果你熟悉 redis-cli 的命令，CSRedis 可以直接上手，学习成本就低很多。\n安装 CSRedis 直接使用 Visual Studio 中的 Nuget 包管理器搜索安装即可，使用连接字符串创建 redis 实例，并执行RedisHelper.Initialization()进行初始化。\nvar csredis = new CSRedisClient(\u0026#34;127.0.0.1:6379,password=YourPassword\u0026#34;); RedisHelper.Initialization(csredis); 如果你没有给 redis 设置密码，那么直接写上ip就行，否则的话要把password写进连接字符串中。\nvar csredis = new CSRedisClient(\u0026#34;127.0.0.1:6379\u0026#34;); RedisHelper.Initialization(csredis); 然后就可以进行操作了。\n字符串 | string 关于字符串的value：\nvalue 可以用来存储任意格式的数据，如 json、jpg 甚至是视频文件； value 的最大容量是512M； value 可以存储3种类型的值：字节串（byte string）、整数（int）、浮点数（double）； 其中，整数的取值范围和系统的长整数取值范围相同，在32位的操作系统上，整数就是32位的；在64位操作系统上，整数就是64位有符号整数。浮点数的取值范围和 IEEE 754 标准的双精度浮点数相同。\n// 添加字符串键-值对 csredis.Set(\u0026#34;hello\u0026#34;, \u0026#34;1\u0026#34;); csredis.Set(\u0026#34;world\u0026#34;, \u0026#34;2\u0026#34;); csredis.Set(\u0026#34;hello\u0026#34;, \u0026#34;3\u0026#34;); // 根据键获取对应的值 csredis.Get(\u0026#34;hello\u0026#34;); // 移除元素 csredis.Del(\u0026#34;world\u0026#34;); 在对同一个键多次赋值时，该键的值是最后一次赋值时的值，实例中hello对应的值最终为3。\n由于 redis 可以对字符串的类型进行“识别”，所以除了对字符串进行增、删、查、之外，我们还可以对整数类型进行自增、自减操作，对字节串的一部分进行读取或者写入。以下是字符串的基本用法\n/* 数值操作 */ csredis.Set(\u0026#34;num-key\u0026#34;, \u0026#34;24\u0026#34;); // value += 5 csredis.IncrBy(\u0026#34;num-key\u0026#34;,5); // output -\u0026gt; 29 // value -= 10 csredis.IncrBy(\u0026#34;num-key\u0026#34;, -10); // output -\u0026gt; 19 /* 字节串操作 */ csredis.Set(\u0026#34;string-key\u0026#34;, \u0026#34;hello \u0026#34;); // 在指定key的value末尾追加字符串 csredis.Append(\u0026#34;string-key\u0026#34;, \u0026#34;world\u0026#34;); // output -\u0026gt; \u0026#34;hello world\u0026#34; // 获取从指定范围所有字符构成的子串（start:3,end:7） csredis.GetRange(\u0026#34;string-key\u0026#34;,3,7) // output -\u0026gt; \u0026#34;lo wo\u0026#34; // 用新字符串从指定位置覆写原value（index:4） csredis.SetRange(\u0026#34;string-key\u0026#34;, 4, \u0026#34;aa\u0026#34;); // output -\u0026gt; \u0026#34;hellaaword\u0026#34; 有一些非正常情况需要注意：对字节串进行自增、自减操作时，redis 会报错；使用Append、SetRange方法对value进行写入时，字节串的长度可能不够用，这时redis会使用空字符(null)将value扩充到指定长度，然后再进行写入操作。\n列表 | list 列表可以有序的存储多个字符串（字符串可以重复）等操作， 列表是通过链表来实现的，所以它添加新元素的速度非常快。\n// 从右端推入元素 csredis.RPush(\u0026#34;my-list\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;, \u0026#34;item3\u0026#34;, \u0026#34;item4\u0026#34;); // 从右端弹出元素 csredis.RPop(\u0026#34;my-list\u0026#34;); // 从左端推入元素 csredis.LPush(\u0026#34;my-list\u0026#34;,\u0026#34;LeftPushItem\u0026#34;); // 从左端弹出元素 csredis.LPop(\u0026#34;my-list\u0026#34;); // 遍历链表元素（start:0,end:-1即可返回所有元素） foreach (var item in csredis.LRange(\u0026#34;my-list\u0026#34;, 0, -1)) { Console.WriteLine(item); } // 按索引值获取元素（当索引值大于链表长度，返回空值，不会报错） Console.WriteLine($\u0026#34;{csredis.LIndex(\u0026#34;my-list\u0026#34;, 1)}\u0026#34;); // 修剪指定范围内的元素（start:4,end:10） csredis.LTrim(\u0026#34;my-list\u0026#34;, 4, 10); 除了对列表中的元素进行以上简单的处理之外，还可以将一个列表中的元素复制到另一个列表中。在语义上，列表的左端默认为「头部」，列表的右端为「尾部」。\n// 将my-list最后一个元素弹出并压入another-list的头部 csredis.RPopLPush(\u0026#34;my-list\u0026#34;, \u0026#34;another-list\u0026#34;); 集合 | set 集合以无序的方式存储各不相同的元素，也就是说在集合中的每个元素的Key都不重复。在redis中可以快速地对集合执行添加、移除等操作。\n// 实际上只插入了两个元素(\u0026#34;item1\u0026#34;,\u0026#34;item2\u0026#34;) csredis.SAdd(\u0026#34;my-set\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;); // 集合的遍历 foreach (var member in csredis.SMembers(\u0026#34;my-set\u0026#34;)) { Console.WriteLine($\u0026#34;集合成员：{member.ToString()}\u0026#34;); } // 判断元素是否存在 string member = \u0026#34;item1\u0026#34;; Console.WriteLine($\u0026#34;{member}是否存在:{csredis.SIsMember(\u0026#34;my-set\u0026#34;, member)}\u0026#34;); // output -\u0026gt; True // 移除元素 csredis.SRem(\u0026#34;my-set\u0026#34;, member); Console.WriteLine($\u0026#34;{member}是否存在:{csredis.SIsMember(\u0026#34;my-set\u0026#34;, member)}\u0026#34;); // output -\u0026gt; False // 随机移除一个元素 csredis.SPop(\u0026#34;my-set\u0026#34;); 以上是对一个集合中的元素进行操作，除此之外还可以对两个集合进行交、并、差操作\ncsredis.SAdd(\u0026#34;set-a\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;, \u0026#34;item3\u0026#34;,\u0026#34;item4\u0026#34;,\u0026#34;item5\u0026#34;); csredis.SAdd(\u0026#34;set-b\u0026#34;, \u0026#34;item2\u0026#34;, \u0026#34;item5\u0026#34;, \u0026#34;item6\u0026#34;, \u0026#34;item7\u0026#34;); // 差集 csredis.SDiff(\u0026#34;set-a\u0026#34;, \u0026#34;set-b\u0026#34;); // output -\u0026gt; \u0026#34;item1\u0026#34;, \u0026#34;item3\u0026#34;,\u0026#34;item4\u0026#34; // 交集 csredis.SInter(\u0026#34;set-a\u0026#34;, \u0026#34;set-b\u0026#34;); // output -\u0026gt; \u0026#34;item2\u0026#34;,\u0026#34;item5\u0026#34; // 并集 csredis.SUnion(\u0026#34;set-a\u0026#34;, \u0026#34;set-b\u0026#34;); // output -\u0026gt; \u0026#34;item1\u0026#34;,\u0026#34;item2\u0026#34;,\u0026#34;item3\u0026#34;,\u0026#34;item4\u0026#34;,\u0026#34;item5\u0026#34;,\u0026#34;item6\u0026#34;,\u0026#34;item7\u0026#34; 另外还可以用SDiffStore,SInterStore,SUnionStore将操作后的结果存储在新的集合中。\n散列 | hashmap 在redis中我们可以使用散列将多个键-值对存储在一个 redis 键上，从而达到将一系列相关数据存放在一起的目的。例如添加一个 redis 键Article:1001,然后在这个键中存放ID为1001的文章的标题、作者、链接、点赞数等信息。我们可以把这样数据集看作是关系数据库中的行。\n// 向散列添加元素 csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Title\u0026#34;, \u0026#34;在.NET Core中使用CSRedis\u0026#34;); csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Author\u0026#34;, \u0026#34;xscape\u0026#34;); csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;PublishTime\u0026#34;, \u0026#34;2019-01-01\u0026#34;); csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Link\u0026#34;,\u0026#34;https://www.cnblogs.com/xscape/p/10208638.html\u0026#34;); // 根据Key获取散列中的元素 csredis.HGet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Title\u0026#34;); // 获取散列中的所有元素 foreach (var item in csredis.HGetAll(\u0026#34;ArticleID:10001\u0026#34;)) { Console.WriteLine(item.Value); } HGet和HSet方法执行一次只能处理一个键值对，而HMGet和HMSet是他们的多参数版本，一次可以处理多个键值对。\nvar keys = new string[] { \u0026#34;Title\u0026#34;,\u0026#34;Author\u0026#34;,\u0026#34;publishTime\u0026#34;}; csredis.HMGet(\u0026#34;ArticleID:10001\u0026#34;, keys); 虽然使用HGetAll可以取出所有的value，但是有时候散列包含的值可能非常大，容易造成服务器的堵塞，为了避免这种情况，我们可以使用HKeys取到散列的所有键(HVals可以取出所有值)，然后再使用HGet方法一个一个地取出键对应的值。\nforeach (var item in csredis.HKeys(\u0026#34;ArticleID:10001\u0026#34;)) { Console.WriteLine($\u0026#34;{item} - {csredis.HGet(\u0026#34;ArticleID:10001\u0026#34;, item)}\u0026#34;); } 和处理字符串一样，我们也可以对散列中的值进行自增、自减操作，原理同字符串是一样的。\ncsredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;votes\u0026#34;, \u0026#34;257\u0026#34;); csredis.HIncrBy(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;votes\u0026#34;, 40); // output -\u0026gt; 297 有序集合 | zset 有序集合可以看作是可排序的 set，不过有序集合的value叫做score(分值)，集合内的元素就是基于score进行排序的，score以双精度浮点数的格式存储。\n// 向有序集合添加元素 csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (79, \u0026#34;Math\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (98, \u0026#34;English\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (87, \u0026#34;Algorithm\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (84, \u0026#34;Database\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (59, \u0026#34;Operation System\u0026#34;)); //返回集合中的元素数量 csredis.ZCard(\u0026#34;Quiz\u0026#34;); // 获取集合中指定范围(90~100)的元素集合 csredis.ZRangeByScore(\u0026#34;Quiz\u0026#34;,90,100); // 获取集合所有元素并升序排序 csredis.ZRangeWithScores(\u0026#34;Quiz\u0026#34;, 0, -1); // 移除集合中的元素 csredis.ZRem(\u0026#34;Quiz\u0026#34;, \u0026#34;Math\u0026#34;); 管道 | pipeline redis 的事务可以通过 pipeline 实现的，使用 pipeline 时，客户端会自动调用MULTI和EXEX命令，将多条命令打包并一次性地发送给redis，然后redis再将命令的执行结果全部打包并一次性返回给客户端，这样有效的减少了redis 与客户端的通信次数，提升执行多次命令时的性能。\nvar pipe = csredis.StartPipe(); for (int i = 0; i \u0026lt; COUNT; i++) { pipe.IncrBy(\u0026#34;key-one\u0026#34;); // 将key-one中的值自增 COUNT 次，产生了 COUNT 条`IncrBy`命令 } pipe.EndPipe(); // 在管道结束的位置，将COUNT条命令一次性发送给 redis Console.WriteLine($\u0026#34;{csredis.Get(\u0026#34;key-one\u0026#34;)}\u0026#34;); Console.ReadKey(); 需要特别说明的是，redis 中的事务不同于数据库的事务，如果执行命令期间发生错误，redis 并不会回滚。\nKey 的过期 redis 还允许我们为key设置有效期，当key过期之后，key就不存在了。\nredis.Set(\u0026#34;MyKey\u0026#34;, \u0026#34;hello,world\u0026#34;); Console.WriteLine(redis.Get(\u0026#34;MyKey\u0026#34;)); // output -\u0026gt; \u0026#34;hello,world\u0026#34; redis.Expire(\u0026#34;MyKey\u0026#34;, 5); // key在5秒后过期，也可以使用ExpireAt方法让它在指定时间自动过期 Thread.Sleep(6000); // 暂停6秒 Console.WriteLine(redis.Get(\u0026#34;MyKey\u0026#34;)); // output -\u0026gt; \u0026#34;\u0026#34; 引用 Redis命令参考 Redis实战 An introduction to Redis data types and abstractions .NET Core简单且高级的库 Github:CSRedis ","permalink":"https://xscape.dev/posts/net-csredis/","summary":"此文章详细讲解了 CSRedis 的安装和常见功能的使用方法，包括字符串、列表、集合、散列、有序集合、管道及键的过期设置等内容，适合初学者快速上手。","title":"在 .NET 中使用 Redis"}]