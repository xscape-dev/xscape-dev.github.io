[{"content":" 为什么选择 CSRedis 1.ServiceStack.Redis 是商业版，免费版有限制。 2.StackExchange.Redis 是免费版，但是内核在 .NET Core 运行有问题经常 Timeout，暂无法解决。 3.CSRedis 于 2016 年开始支持 .NET Core 一直迭代至今，实现了低门槛、高性能，和分区高级玩法。\n在 v3.0 版本更新中，CSRedis 中的所有方法名称进行了调整，使其和 redis-cli 保持一致，如果你熟悉 redis-cli 的命令，CSRedis 可以直接上手，学习成本就低很多。\n安装 CSRedis 直接使用 Visual Studio 中的 Nuget 包管理器搜索安装即可，使用连接字符串创建 redis 实例，并执行RedisHelper.Initialization()进行初始化。\nvar csredis = new CSRedisClient(\u0026#34;127.0.0.1:6379,password=YourPassword\u0026#34;); RedisHelper.Initialization(csredis); 如果你没有给 redis 设置密码，那么直接写上ip就行，否则的话要把password写进连接字符串中。\nvar csredis = new CSRedisClient(\u0026#34;127.0.0.1:6379\u0026#34;); RedisHelper.Initialization(csredis); 然后就可以进行操作了。\n字符串(string) 关于字符串的value：\nvalue 可以用来存储任意格式的数据，如 json、jpg 甚至是视频文件； value 的最大容量是512M； value 可以存储3种类型的值：字节串（byte string）、整数（int）、浮点数（double）； 其中，整数的取值范围和系统的长整数取值范围相同，在32位的操作系统上，整数就是32位的；在64位操作系统上，整数就是64位有符号整数。浮点数的取值范围和 IEEE 754 标准的双精度浮点数相同。\n// 添加字符串键-值对 csredis.Set(\u0026#34;hello\u0026#34;, \u0026#34;1\u0026#34;); csredis.Set(\u0026#34;world\u0026#34;, \u0026#34;2\u0026#34;); csredis.Set(\u0026#34;hello\u0026#34;, \u0026#34;3\u0026#34;); // 根据键获取对应的值 csredis.Get(\u0026#34;hello\u0026#34;); // 移除元素 csredis.Del(\u0026#34;world\u0026#34;); 在对同一个键多次赋值时，该键的值是最后一次赋值时的值，实例中hello对应的值最终为3。\n由于 redis 可以对字符串的类型进行“识别”，所以除了对字符串进行增、删、查、之外，我们还可以对整数类型进行自增、自减操作，对字节串的一部分进行读取或者写入。以下是字符串的基本用法\n/* 数值操作 */ csredis.Set(\u0026#34;num-key\u0026#34;, \u0026#34;24\u0026#34;); // value += 5 csredis.IncrBy(\u0026#34;num-key\u0026#34;,5); // output -\u0026gt; 29 // value -= 10 csredis.IncrBy(\u0026#34;num-key\u0026#34;, -10); // output -\u0026gt; 19 /* 字节串操作 */ csredis.Set(\u0026#34;string-key\u0026#34;, \u0026#34;hello \u0026#34;); // 在指定key的value末尾追加字符串 csredis.Append(\u0026#34;string-key\u0026#34;, \u0026#34;world\u0026#34;); // output -\u0026gt; \u0026#34;hello world\u0026#34; // 获取从指定范围所有字符构成的子串（start:3,end:7） csredis.GetRange(\u0026#34;string-key\u0026#34;,3,7) // output -\u0026gt; \u0026#34;lo wo\u0026#34; // 用新字符串从指定位置覆写原value（index:4） csredis.SetRange(\u0026#34;string-key\u0026#34;, 4, \u0026#34;aa\u0026#34;); // output -\u0026gt; \u0026#34;hellaaword\u0026#34; 有一些非正常情况需要注意：对字节串进行自增、自减操作时，redis 会报错；使用Append、SetRange方法对value进行写入时，字节串的长度可能不够用，这时redis会使用空字符(null)将value扩充到指定长度，然后再进行写入操作。\n列表(list) 列表可以有序的存储多个字符串（字符串可以重复）等操作， 列表是通过链表来实现的，所以它添加新元素的速度非常快。\n// 从右端推入元素 csredis.RPush(\u0026#34;my-list\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;, \u0026#34;item3\u0026#34;, \u0026#34;item4\u0026#34;); // 从右端弹出元素 csredis.RPop(\u0026#34;my-list\u0026#34;); // 从左端推入元素 csredis.LPush(\u0026#34;my-list\u0026#34;,\u0026#34;LeftPushItem\u0026#34;); // 从左端弹出元素 csredis.LPop(\u0026#34;my-list\u0026#34;); // 遍历链表元素（start:0,end:-1即可返回所有元素） foreach (var item in csredis.LRange(\u0026#34;my-list\u0026#34;, 0, -1)) { Console.WriteLine(item); } // 按索引值获取元素（当索引值大于链表长度，返回空值，不会报错） Console.WriteLine($\u0026#34;{csredis.LIndex(\u0026#34;my-list\u0026#34;, 1)}\u0026#34;); // 修剪指定范围内的元素（start:4,end:10） csredis.LTrim(\u0026#34;my-list\u0026#34;, 4, 10); 除了对列表中的元素进行以上简单的处理之外，还可以将一个列表中的元素复制到另一个列表中。在语义上，列表的左端默认为「头部」，列表的右端为「尾部」。\n// 将my-list最后一个元素弹出并压入another-list的头部 csredis.RPopLPush(\u0026#34;my-list\u0026#34;, \u0026#34;another-list\u0026#34;); 集合(set) 集合以无序的方式存储各不相同的元素，也就是说在集合中的每个元素的Key都不重复。在redis中可以快速地对集合执行添加、移除等操作。\n// 实际上只插入了两个元素(\u0026#34;item1\u0026#34;,\u0026#34;item2\u0026#34;) csredis.SAdd(\u0026#34;my-set\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;); // 集合的遍历 foreach (var member in csredis.SMembers(\u0026#34;my-set\u0026#34;)) { Console.WriteLine($\u0026#34;集合成员：{member.ToString()}\u0026#34;); } // 判断元素是否存在 string member = \u0026#34;item1\u0026#34;; Console.WriteLine($\u0026#34;{member}是否存在:{csredis.SIsMember(\u0026#34;my-set\u0026#34;, member)}\u0026#34;); // output -\u0026gt; True // 移除元素 csredis.SRem(\u0026#34;my-set\u0026#34;, member); Console.WriteLine($\u0026#34;{member}是否存在:{csredis.SIsMember(\u0026#34;my-set\u0026#34;, member)}\u0026#34;); // output -\u0026gt; False // 随机移除一个元素 csredis.SPop(\u0026#34;my-set\u0026#34;); 以上是对一个集合中的元素进行操作，除此之外还可以对两个集合进行交、并、差操作\ncsredis.SAdd(\u0026#34;set-a\u0026#34;, \u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;, \u0026#34;item3\u0026#34;,\u0026#34;item4\u0026#34;,\u0026#34;item5\u0026#34;); csredis.SAdd(\u0026#34;set-b\u0026#34;, \u0026#34;item2\u0026#34;, \u0026#34;item5\u0026#34;, \u0026#34;item6\u0026#34;, \u0026#34;item7\u0026#34;); // 差集 csredis.SDiff(\u0026#34;set-a\u0026#34;, \u0026#34;set-b\u0026#34;); // output -\u0026gt; \u0026#34;item1\u0026#34;, \u0026#34;item3\u0026#34;,\u0026#34;item4\u0026#34; // 交集 csredis.SInter(\u0026#34;set-a\u0026#34;, \u0026#34;set-b\u0026#34;); // output -\u0026gt; \u0026#34;item2\u0026#34;,\u0026#34;item5\u0026#34; // 并集 csredis.SUnion(\u0026#34;set-a\u0026#34;, \u0026#34;set-b\u0026#34;); // output -\u0026gt; \u0026#34;item1\u0026#34;,\u0026#34;item2\u0026#34;,\u0026#34;item3\u0026#34;,\u0026#34;item4\u0026#34;,\u0026#34;item5\u0026#34;,\u0026#34;item6\u0026#34;,\u0026#34;item7\u0026#34; 另外还可以用SDiffStore,SInterStore,SUnionStore将操作后的结果存储在新的集合中。\n散列(hashmap) 在redis中我们可以使用散列将多个键-值对存储在一个 redis 键上，从而达到将一系列相关数据存放在一起的目的。例如添加一个 redis 键Article:1001,然后在这个键中存放ID为1001的文章的标题、作者、链接、点赞数等信息。我们可以把这样数据集看作是关系数据库中的行。\n// 向散列添加元素 csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Title\u0026#34;, \u0026#34;在.NET Core中使用CSRedis\u0026#34;); csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Author\u0026#34;, \u0026#34;xscape\u0026#34;); csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;PublishTime\u0026#34;, \u0026#34;2019-01-01\u0026#34;); csredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Link\u0026#34;,\u0026#34;https://www.cnblogs.com/xscape/p/10208638.html\u0026#34;); // 根据Key获取散列中的元素 csredis.HGet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;Title\u0026#34;); // 获取散列中的所有元素 foreach (var item in csredis.HGetAll(\u0026#34;ArticleID:10001\u0026#34;)) { Console.WriteLine(item.Value); } HGet和HSet方法执行一次只能处理一个键值对，而HMGet和HMSet是他们的多参数版本，一次可以处理多个键值对。\nvar keys = new string[] { \u0026#34;Title\u0026#34;,\u0026#34;Author\u0026#34;,\u0026#34;publishTime\u0026#34;}; csredis.HMGet(\u0026#34;ArticleID:10001\u0026#34;, keys); 虽然使用HGetAll可以取出所有的value，但是有时候散列包含的值可能非常大，容易造成服务器的堵塞，为了避免这种情况，我们可以使用HKeys取到散列的所有键(HVals可以取出所有值)，然后再使用HGet方法一个一个地取出键对应的值。\nforeach (var item in csredis.HKeys(\u0026#34;ArticleID:10001\u0026#34;)) { Console.WriteLine($\u0026#34;{item} - {csredis.HGet(\u0026#34;ArticleID:10001\u0026#34;, item)}\u0026#34;); } 和处理字符串一样，我们也可以对散列中的值进行自增、自减操作，原理同字符串是一样的。\ncsredis.HSet(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;votes\u0026#34;, \u0026#34;257\u0026#34;); csredis.HIncrBy(\u0026#34;ArticleID:10001\u0026#34;, \u0026#34;votes\u0026#34;, 40); // output -\u0026gt; 297 有序集合 有序集合可以看作是可排序的 set，不过有序集合的value叫做score(分值)，集合内的元素就是基于score进行排序的，score以双精度浮点数的格式存储。\n// 向有序集合添加元素 csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (79, \u0026#34;Math\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (98, \u0026#34;English\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (87, \u0026#34;Algorithm\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (84, \u0026#34;Database\u0026#34;)); csredis.ZAdd(\u0026#34;Quiz\u0026#34;, (59, \u0026#34;Operation System\u0026#34;)); //返回集合中的元素数量 csredis.ZCard(\u0026#34;Quiz\u0026#34;); // 获取集合中指定范围(90~100)的元素集合 csredis.ZRangeByScore(\u0026#34;Quiz\u0026#34;,90,100); // 获取集合所有元素并升序排序 csredis.ZRangeWithScores(\u0026#34;Quiz\u0026#34;, 0, -1); // 移除集合中的元素 csredis.ZRem(\u0026#34;Quiz\u0026#34;, \u0026#34;Math\u0026#34;); 管道(pipeline) redis 的事务可以通过 pipeline 实现的，使用 pipeline 时，客户端会自动调用MULTI和EXEX命令，将多条命令打包并一次性地发送给redis，然后redis再将命令的执行结果全部打包并一次性返回给客户端，这样有效的减少了redis 与客户端的通信次数，提升执行多次命令时的性能。\nvar pipe = csredis.StartPipe(); for (int i = 0; i \u0026lt; COUNT; i++) { pipe.IncrBy(\u0026#34;key-one\u0026#34;); // 将key-one中的值自增 COUNT 次，产生了 COUNT 条`IncrBy`命令 } pipe.EndPipe(); // 在管道结束的位置，将COUNT条命令一次性发送给 redis Console.WriteLine($\u0026#34;{csredis.Get(\u0026#34;key-one\u0026#34;)}\u0026#34;); Console.ReadKey(); 需要特别说明的是，redis 中的事务不同于数据库的事务，如果执行命令期间发生错误，redis 并不会回滚。\nKey的过期 redis 还允许我们为key设置有效期，当key过期之后，key就不存在了。\nredis.Set(\u0026#34;MyKey\u0026#34;, \u0026#34;hello,world\u0026#34;); Console.WriteLine(redis.Get(\u0026#34;MyKey\u0026#34;)); // output -\u0026gt; \u0026#34;hello,world\u0026#34; redis.Expire(\u0026#34;MyKey\u0026#34;, 5); // key在5秒后过期，也可以使用ExpireAt方法让它在指定时间自动过期 Thread.Sleep(6000); // 暂停6秒 Console.WriteLine(redis.Get(\u0026#34;MyKey\u0026#34;)); // output -\u0026gt; \u0026#34;\u0026#34; 引用 Redis命令参考 Redis实战 An introduction to Redis data types and abstractions .NET Core简单且高级的库 Github:CSRedis ","permalink":"https://xscape.dev/posts/net-csredis/","summary":"\u003cdiv class=\"details admonition info open\"\u003e\n        \u003cdiv class=\"details-summary admonition-title\"\u003e\n            \u003ci class=\"icon fas fa-info-circle fa-fw\"\u003e\u003c/i\u003e为什么选择 CSRedis\u003ci class=\"details-icon fas fa-angle-right fa-fw\"\u003e\u003c/i\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"details-content\"\u003e\n            \u003cdiv class=\"admonition-content\"\u003e\u003cp\u003e1.ServiceStack.Redis 是商业版，免费版有限制。   \u003cbr\u003e\n2.StackExchange.Redis 是免费版，但是内核在 .NET Core 运行有问题经常 Timeout，暂无法解决。    \u003cbr\u003e\n3.CSRedis 于 2016 年开始支持 .NET Core 一直迭代至今，实现了低门槛、高性能，和分区高级玩法。\u003c/p\u003e\n\u003cp\u003e在 v3.0 版本更新中，CSRedis 中的所有方法名称进行了调整，使其和 redis-cli 保持一致，如果你熟悉 redis-cli 的命令，CSRedis 可以直接上手，学习成本就低很多。\u003c/p\u003e\n\u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\u003ch2 id=\"安装-csredis\"\u003e安装 CSRedis\u003c/h2\u003e\n\u003cp\u003e直接使用 Visual Studio 中的 Nuget 包管理器搜索安装即可，使用连接字符串创建 redis 实例，并执行\u003ccode\u003eRedisHelper.Initialization()\u003c/code\u003e进行初始化。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-csharp\" data-lang=\"csharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eCSRedisClient\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;127.0.0.1:6379,password=YourPassword\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eRedisHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eInitialization\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果你没有给 redis 设置密码，那么直接写上\u003ccode\u003eip\u003c/code\u003e就行，否则的话要把\u003ccode\u003epassword\u003c/code\u003e写进连接字符串中。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-csharp\" data-lang=\"csharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eCSRedisClient\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;127.0.0.1:6379\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eRedisHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eInitialization\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后就可以进行操作了。\u003c/p\u003e\n\u003ch2 id=\"字符串string\"\u003e字符串(string)\u003c/h2\u003e\n\u003cp\u003e关于字符串的\u003ccode\u003evalue\u003c/code\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003evalue\u003c/code\u003e 可以用来存储任意格式的数据，如 json、jpg 甚至是视频文件；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue\u003c/code\u003e 的最大容量是512M；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue\u003c/code\u003e 可以存储3种类型的值：字节串（byte string）、整数（int）、浮点数（double）；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e其中，整数的取值范围和系统的长整数取值范围相同，在32位的操作系统上，整数就是32位的；在64位操作系统上，整数就是64位有符号整数。浮点数的取值范围和 IEEE 754 标准的双精度浮点数相同。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-csharp\" data-lang=\"csharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 添加字符串键-值对\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSet\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;1\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSet\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;world\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;2\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSet\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;3\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 根据键获取对应的值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGet\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 移除元素\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecsredis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDel\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;world\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在对同一个键多次赋值时，该键的值是最后一次赋值时的值，实例中\u003ccode\u003ehello\u003c/code\u003e对应的值最终为\u003ccode\u003e3\u003c/code\u003e。\u003c/p\u003e","title":"在 .NET 中使用 Redis"}]