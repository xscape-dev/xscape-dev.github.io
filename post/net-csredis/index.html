<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>在.NET中使用Redis - XSCAPE’s Blog</title>
<meta name=theme-color><meta name=description content='为什么选择CSRedis

ServiceStack.Redis 是商业版，免费版有限制；
StackExchange.Redis 是免费版，但是内核在 .NETCore 运行有问题经常 Timeout，暂无法解决；
CSRedis 于 2016 年开始支持 .NETCore 一直迭代至今，实现了低门槛、高性能，和分区高级玩法的 .NETCore redis-cli SDK；

在 v3.0 版本更新中，CSRedis 中的所有方法名称进行了调整，使其和 redis-cli 保持一致，如果你熟悉 redis-cli 的命令，CSRedis 可以直接上手，学习成本就低很多。
安装CSRedis 😸
直接使用 Visual Studio 中的 Nuget 包管理器搜索安装即可，使用连接字符串创建 redis 实例，并执行RedisHelper.Initialization()进行初始化。
var csredis = new CSRedisClient("127.0.0.1:6379,password=YourPassword");
RedisHelper.Initialization(csredis);
如果你没有给redis设置密码，那么直接写上ip就行，否则的话要把password写进连接字符串中。
var csredis = new CSRedisClient("127.0.0.1:6379");
RedisHelper.Initialization(csredis);
然后就可以进行redis操作了。
字符串(string)
关于字符串的value：

value 可以用来存储任意格式的数据，如 json、jpg 甚至是视频文件；
value 的最大容量是512M；
value 可以存储3种类型的值：字节串（byte string）、整数（int）、浮点数（double）；

其中，整数的取值范围和系统的长整数取值范围相同，在32位的操作系统上，整数就是32位的；在64位操作系统上，整数就是64位有符号整数。浮点数的取值范围和 IEEE 754 标准的双精度浮点数相同。
// 添加字符串键-值对
csredis.Set("hello", "1");
csredis.Set("world", "2");
csredis.Set("hello", "3");

// 根据键获取对应的值
csredis.Get("hello");

// 移除元素
csredis.Del("world");
在对同一个键多次赋值时，该键的值是最后一次赋值时的值，实例中hello对应的值最终为3。'><meta name=author content="XSCAPE"><link rel="preload stylesheet" as=style href=https://xscape.dev/main.min.css><link rel=preload as=image href=https://xscape.dev/theme.png><link rel=preload as=image href="https://www.gravatar.com/avatar/753e84788d5f4ef728fa0b4d9f46c422?s=160&amp;d=identicon"><link rel=preload as=image href=https://xscape.dev/twitter.svg><link rel=preload as=image href=https://xscape.dev/github.svg><link rel=preload as=image href=https://xscape.dev/instagram.svg><script defer src=https://xscape.dev/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://xscape.dev/favicon.ico><link rel=apple-touch-icon href=https://xscape.dev/apple-touch-icon.png><meta name=generator content="Hugo 0.139.2"><meta itemprop=name content="在.NET中使用Redis"><meta itemprop=description content="Desc Text."><meta itemprop=datePublished content="2023-03-26T20:51:41+08:00"><meta itemprop=dateModified content="2023-03-26T20:51:41+08:00"><meta itemprop=wordCount content="420"><meta itemprop=keywords content=".Net,Redis"><meta property="og:url" content="https://xscape.dev/post/net-csredis/"><meta property="og:site_name" content="XSCAPE’s Blog"><meta property="og:title" content="在.NET中使用Redis"><meta property="og:description" content="Desc Text."><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-26T20:51:41+08:00"><meta property="article:modified_time" content="2023-03-26T20:51:41+08:00"><meta property="article:tag" content=".Net"><meta property="article:tag" content="Redis"><meta name=twitter:card content="summary"><meta name=twitter:title content="在.NET中使用Redis"><meta name=twitter:description content="Desc Text."><link rel=canonical href=https://xscape.dev/post/net-csredis/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://xscape.dev/>XSCAPE’s Blog</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>文章</a>
<a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags/>标签</a>
<a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>关于</a></nav><nav class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/nanxiaobei target=_blank rel=me>twitter
</a><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/xscape-dev target=_blank rel=me>github
</a><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/nan.xiaobei target=_blank rel=me>instagram</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">在.NET中使用Redis</h1><div class="text-xs antialiased opacity-60"><time>2023年3月26日</time></div></header><section><h2 id=为什么选择csredis>为什么选择CSRedis</h2><ol><li>ServiceStack.Redis 是商业版，免费版有限制；</li><li>StackExchange.Redis 是免费版，但是内核在 .NETCore 运行有问题经常 Timeout，暂无法解决；</li><li>CSRedis 于 2016 年开始支持 .NETCore 一直迭代至今，实现了低门槛、高性能，和分区高级玩法的 .NETCore redis-cli SDK；</li></ol><p>在 v3.0 版本更新中，CSRedis 中的所有方法名称进行了调整，使其和 redis-cli 保持一致，如果你熟悉 redis-cli 的命令，CSRedis 可以直接上手，学习成本就低很多。</p><h2 id=安装csredis-x1f638>安装CSRedis 😸</h2><p>直接使用 Visual Studio 中的 Nuget 包管理器搜索安装即可，使用连接字符串创建 redis 实例，并执行<code>RedisHelper.Initialization()</code>进行初始化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> csredis = <span style=color:#66d9ef>new</span> CSRedisClient(<span style=color:#e6db74>&#34;127.0.0.1:6379,password=YourPassword&#34;</span>);
</span></span><span style=display:flex><span>RedisHelper.Initialization(csredis);
</span></span></code></pre></div><p>如果你没有给redis设置密码，那么直接写上ip就行，否则的话要把password写进连接字符串中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> csredis = <span style=color:#66d9ef>new</span> CSRedisClient(<span style=color:#e6db74>&#34;127.0.0.1:6379&#34;</span>);
</span></span><span style=display:flex><span>RedisHelper.Initialization(csredis);
</span></span></code></pre></div><p>然后就可以进行redis操作了。</p><h2 id=字符串string>字符串(string)</h2><p>关于字符串的<code>value</code>：</p><ol><li>value 可以用来存储任意格式的数据，如 json、jpg 甚至是视频文件；</li><li>value 的最大容量是512M；</li><li>value 可以存储3种类型的值：字节串（byte string）、整数（int）、浮点数（double）；</li></ol><p>其中，整数的取值范围和系统的长整数取值范围相同，在32位的操作系统上，整数就是32位的；在64位操作系统上，整数就是64位有符号整数。浮点数的取值范围和 IEEE 754 标准的双精度浮点数相同。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// 添加字符串键-值对</span>
</span></span><span style=display:flex><span>csredis.Set(<span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#e6db74>&#34;1&#34;</span>);
</span></span><span style=display:flex><span>csredis.Set(<span style=color:#e6db74>&#34;world&#34;</span>, <span style=color:#e6db74>&#34;2&#34;</span>);
</span></span><span style=display:flex><span>csredis.Set(<span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#e6db74>&#34;3&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 根据键获取对应的值</span>
</span></span><span style=display:flex><span>csredis.Get(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 移除元素</span>
</span></span><span style=display:flex><span>csredis.Del(<span style=color:#e6db74>&#34;world&#34;</span>);
</span></span></code></pre></div><p>在对同一个键多次赋值时，该键的值是最后一次赋值时的值，实例中<code>hello</code>对应的值最终为<code>3</code>。</p><p>由于redis可以对字符串的类型进行“识别”，所以除了对字符串进行增、删、查、之外，我们还可以对整数类型进行自增、自减操作，对字节串的一部分进行读取或者写入。以下是字符串的基本用法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>/*    数值操作    */</span>
</span></span><span style=display:flex><span>csredis.Set(<span style=color:#e6db74>&#34;num-key&#34;</span>, <span style=color:#e6db74>&#34;24&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// value += 5</span>
</span></span><span style=display:flex><span>csredis.IncrBy(<span style=color:#e6db74>&#34;num-key&#34;</span>,<span style=color:#ae81ff>5</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; 29</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// value -= 10</span>
</span></span><span style=display:flex><span>csredis.IncrBy(<span style=color:#e6db74>&#34;num-key&#34;</span>, -<span style=color:#ae81ff>10</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; 19</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*    字节串操作    */</span>
</span></span><span style=display:flex><span>csredis.Set(<span style=color:#e6db74>&#34;string-key&#34;</span>, <span style=color:#e6db74>&#34;hello &#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在指定key的value末尾追加字符串</span>
</span></span><span style=display:flex><span>csredis.Append(<span style=color:#e6db74>&#34;string-key&#34;</span>, <span style=color:#e6db74>&#34;world&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; &#34;hello world&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取从指定范围所有字符构成的子串（start:3,end:7）</span>
</span></span><span style=display:flex><span>csredis.GetRange(<span style=color:#e6db74>&#34;string-key&#34;</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>7</span>)  
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt;  &#34;lo wo&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e>// 用新字符串从指定位置覆写原value（index:4）</span>
</span></span><span style=display:flex><span>csredis.SetRange(<span style=color:#e6db74>&#34;string-key&#34;</span>, <span style=color:#ae81ff>4</span>, <span style=color:#e6db74>&#34;aa&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; &#34;hellaaword&#34;</span>
</span></span></code></pre></div><p>有一些非正常情况需要注意：对字节串进行自增、自减操作时，redis会报错；使用<code>Append</code>、<code>SetRange</code>方法对value进行写入时，字节串的长度可能不够用，这时redis会使用空字符(null)将value扩充到指定长度，然后再进行写入操作。</p><h2 id=列表list>列表(list)</h2><p>列表可以有序的存储多个字符串（字符串可以重复）等操作， 列表是通过链表来实现的，所以它添加新元素的速度非常快。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// 从右端推入元素</span>
</span></span><span style=display:flex><span>csredis.RPush(<span style=color:#e6db74>&#34;my-list&#34;</span>, <span style=color:#e6db74>&#34;item1&#34;</span>, <span style=color:#e6db74>&#34;item2&#34;</span>, <span style=color:#e6db74>&#34;item3&#34;</span>, <span style=color:#e6db74>&#34;item4&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// 从右端弹出元素</span>
</span></span><span style=display:flex><span>csredis.RPop(<span style=color:#e6db74>&#34;my-list&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 从左端推入元素</span>
</span></span><span style=display:flex><span>csredis.LPush(<span style=color:#e6db74>&#34;my-list&#34;</span>,<span style=color:#e6db74>&#34;LeftPushItem&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 从左端弹出元素</span>
</span></span><span style=display:flex><span>csredis.LPop(<span style=color:#e6db74>&#34;my-list&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 遍历链表元素（start:0,end:-1即可返回所有元素）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> csredis.LRange(<span style=color:#e6db74>&#34;my-list&#34;</span>, <span style=color:#ae81ff>0</span>, -<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(item);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 按索引值获取元素（当索引值大于链表长度，返回空值，不会报错）</span>
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;{csredis.LIndex(&#34;</span>my-list<span style=color:#e6db74>&#34;, 1)}&#34;</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 修剪指定范围内的元素（start:4,end:10）</span>
</span></span><span style=display:flex><span>csredis.LTrim(<span style=color:#e6db74>&#34;my-list&#34;</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>10</span>);
</span></span></code></pre></div><p>除了对列表中的元素进行以上简单的处理之外，还可以将一个列表中的元素复制到另一个列表中。在语义上，列表的左端默认为“头部”，列表的右端为“尾部”。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// 将my-list最后一个元素弹出并压入another-list的头部</span>
</span></span><span style=display:flex><span>csredis.RPopLPush(<span style=color:#e6db74>&#34;my-list&#34;</span>, <span style=color:#e6db74>&#34;another-list&#34;</span>);
</span></span></code></pre></div><h2 id=集合set>集合(set)</h2><p>集合以无序的方式存储<strong>各不相同</strong>的元素，也就是说在集合中的每个元素的<code>Key</code>都不重复。在redis中可以快速地对集合执行添加、移除等操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// 实际上只插入了两个元素(&#34;item1&#34;,&#34;item2&#34;)</span>
</span></span><span style=display:flex><span>csredis.SAdd(<span style=color:#e6db74>&#34;my-set&#34;</span>, <span style=color:#e6db74>&#34;item1&#34;</span>, <span style=color:#e6db74>&#34;item1&#34;</span>, <span style=color:#e6db74>&#34;item2&#34;</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 集合的遍历</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> member <span style=color:#66d9ef>in</span> csredis.SMembers(<span style=color:#e6db74>&#34;my-set&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(<span style=color:#e6db74>$&#34;集合成员：{member.ToString()}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 判断元素是否存在</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> member = <span style=color:#e6db74>&#34;item1&#34;</span>;
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;{member}是否存在:{csredis.SIsMember(&#34;</span>my-<span style=color:#66d9ef>set</span><span style=color:#e6db74>&#34;, member)}&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 移除元素</span>
</span></span><span style=display:flex><span>csredis.SRem(<span style=color:#e6db74>&#34;my-set&#34;</span>, member);
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;{member}是否存在:{csredis.SIsMember(&#34;</span>my-<span style=color:#66d9ef>set</span><span style=color:#e6db74>&#34;, member)}&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt;  False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 随机移除一个元素</span>
</span></span><span style=display:flex><span>csredis.SPop(<span style=color:#e6db74>&#34;my-set&#34;</span>);
</span></span></code></pre></div><p>以上是对一个集合中的元素进行操作，除此之外还可以对两个集合进行交、并、差操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>csredis.SAdd(<span style=color:#e6db74>&#34;set-a&#34;</span>, <span style=color:#e6db74>&#34;item1&#34;</span>, <span style=color:#e6db74>&#34;item2&#34;</span>, <span style=color:#e6db74>&#34;item3&#34;</span>,<span style=color:#e6db74>&#34;item4&#34;</span>,<span style=color:#e6db74>&#34;item5&#34;</span>);
</span></span><span style=display:flex><span>csredis.SAdd(<span style=color:#e6db74>&#34;set-b&#34;</span>, <span style=color:#e6db74>&#34;item2&#34;</span>, <span style=color:#e6db74>&#34;item5&#34;</span>, <span style=color:#e6db74>&#34;item6&#34;</span>, <span style=color:#e6db74>&#34;item7&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 差集</span>
</span></span><span style=display:flex><span>csredis.SDiff(<span style=color:#e6db74>&#34;set-a&#34;</span>, <span style=color:#e6db74>&#34;set-b&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; &#34;item1&#34;, &#34;item3&#34;,&#34;item4&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 交集</span>
</span></span><span style=display:flex><span>csredis.SInter(<span style=color:#e6db74>&#34;set-a&#34;</span>, <span style=color:#e6db74>&#34;set-b&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; &#34;item2&#34;,&#34;item5&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 并集</span>
</span></span><span style=display:flex><span>csredis.SUnion(<span style=color:#e6db74>&#34;set-a&#34;</span>, <span style=color:#e6db74>&#34;set-b&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; &#34;item1&#34;,&#34;item2&#34;,&#34;item3&#34;,&#34;item4&#34;,&#34;item5&#34;,&#34;item6&#34;,&#34;item7&#34;</span>
</span></span></code></pre></div><p>另外还可以用<code>SDiffStore</code>,<code>SInterStore</code>,<code>SUnionStore</code>将操作后的结果存储在新的集合中。</p><h2 id=散列hashmap>散列(hashmap)</h2><p>在redis中我们可以使用散列将多个键-值对存储在一个redis键上，从而达到将一系列相关数据存放在一起的目的。例如添加一个redis键<code>Article:1001</code>,然后在这个键中存放ID为1001的文章的标题、作者、链接、点赞数等信息。我们可以把这样数据集看作是关系数据库中的行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// 向散列添加元素</span>
</span></span><span style=display:flex><span>csredis.HSet(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, <span style=color:#e6db74>&#34;Title&#34;</span>, <span style=color:#e6db74>&#34;在.NET Core中使用CSRedis&#34;</span>);
</span></span><span style=display:flex><span>csredis.HSet(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, <span style=color:#e6db74>&#34;Author&#34;</span>, <span style=color:#e6db74>&#34;xscape&#34;</span>);
</span></span><span style=display:flex><span>csredis.HSet(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, <span style=color:#e6db74>&#34;PublishTime&#34;</span>, <span style=color:#e6db74>&#34;2019-01-01&#34;</span>);
</span></span><span style=display:flex><span>csredis.HSet(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, <span style=color:#e6db74>&#34;Link&#34;</span>,<span style=color:#e6db74>&#34;https://www.cnblogs.com/xscape/p/10208638.html&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 根据Key获取散列中的元素</span>
</span></span><span style=display:flex><span>csredis.HGet(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, <span style=color:#e6db74>&#34;Title&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取散列中的所有元素</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> csredis.HGetAll(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Console.WriteLine(item.Value);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>HGet</code>和<code>HSet</code>方法执行一次只能处理一个键值对，而<code>HMGet</code>和<code>HMSet</code>是他们的多参数版本，一次可以处理多个键值对。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> keys = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[] { <span style=color:#e6db74>&#34;Title&#34;</span>,<span style=color:#e6db74>&#34;Author&#34;</span>,<span style=color:#e6db74>&#34;publishTime&#34;</span>};
</span></span><span style=display:flex><span>csredis.HMGet(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, keys);
</span></span></code></pre></div><p>虽然使用<code>HGetAll</code>可以取出所有的value，但是<strong>有时候散列包含的值可能非常大，容易造成服务器的堵塞</strong>，为了避免这种情况，我们可以使用<code>HKeys</code>取到散列的所有键(<em><code>HVals可以取出所有值</code></em>)，然后再使用<code>HGet</code>方法一个一个地取出键对应的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> item <span style=color:#66d9ef>in</span> csredis.HKeys(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Console.WriteLine(<span style=color:#e6db74>$&#34;{item} - {csredis.HGet(&#34;</span>ArticleID:<span style=color:#ae81ff>10001</span><span style=color:#e6db74>&#34;, item)}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>和处理字符串一样，我们也可以对散列中的值进行自增、自减操作，原理同字符串是一样的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>csredis.HSet(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, <span style=color:#e6db74>&#34;votes&#34;</span>, <span style=color:#e6db74>&#34;257&#34;</span>);
</span></span><span style=display:flex><span>csredis.HIncrBy(<span style=color:#e6db74>&#34;ArticleID:10001&#34;</span>, <span style=color:#e6db74>&#34;votes&#34;</span>, <span style=color:#ae81ff>40</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; 297</span>
</span></span></code></pre></div><h2 id=有序集合>有序集合</h2><p>有序集合可以看作是可排序的散列，不过有序集合的val成为score分值，集合内的元素就是基于score进行排序的，score以双精度浮点数的格式存储。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// 向有序集合添加元素</span>
</span></span><span style=display:flex><span>csredis.ZAdd(<span style=color:#e6db74>&#34;Quiz&#34;</span>, (<span style=color:#ae81ff>79</span>, <span style=color:#e6db74>&#34;Math&#34;</span>));
</span></span><span style=display:flex><span>csredis.ZAdd(<span style=color:#e6db74>&#34;Quiz&#34;</span>, (<span style=color:#ae81ff>98</span>, <span style=color:#e6db74>&#34;English&#34;</span>));
</span></span><span style=display:flex><span>csredis.ZAdd(<span style=color:#e6db74>&#34;Quiz&#34;</span>, (<span style=color:#ae81ff>87</span>, <span style=color:#e6db74>&#34;Algorithm&#34;</span>));
</span></span><span style=display:flex><span>csredis.ZAdd(<span style=color:#e6db74>&#34;Quiz&#34;</span>, (<span style=color:#ae81ff>84</span>, <span style=color:#e6db74>&#34;Database&#34;</span>));
</span></span><span style=display:flex><span>csredis.ZAdd(<span style=color:#e6db74>&#34;Quiz&#34;</span>, (<span style=color:#ae81ff>59</span>, <span style=color:#e6db74>&#34;Operation System&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//返回集合中的元素数量</span>
</span></span><span style=display:flex><span>csredis.ZCard(<span style=color:#e6db74>&#34;Quiz&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取集合中指定范围(90~100)的元素集合</span>
</span></span><span style=display:flex><span>csredis.ZRangeByScore(<span style=color:#e6db74>&#34;Quiz&#34;</span>,<span style=color:#ae81ff>90</span>,<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取集合所有元素并升序排序</span>
</span></span><span style=display:flex><span>csredis.ZRangeWithScores(<span style=color:#e6db74>&#34;Quiz&#34;</span>, <span style=color:#ae81ff>0</span>, -<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 移除集合中的元素</span>
</span></span><span style=display:flex><span>csredis.ZRem(<span style=color:#e6db74>&#34;Quiz&#34;</span>, <span style=color:#e6db74>&#34;Math&#34;</span>);
</span></span></code></pre></div><h2 id=管道pipeline>管道(pipeline)</h2><p>redis的事务可以通过pipeline实现的，使用pipeline时，客户端会自动调用<code>MULTI</code>和<code>EXEX</code>命令，<strong>将多条命令打包并一次性地发送给redis，然后redis再将命令的执行结果全部打包并一次性返回给客户端</strong>，这样有效的减少了redis与客户端的通信次数，提升执行多次命令时的性能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> pipe = csredis.StartPipe();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; COUNT; i++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    pipe.IncrBy(<span style=color:#e6db74>&#34;key-one&#34;</span>); <span style=color:#75715e>// 将key-one中的值自增COUNT次，产生了COUNT条IncrBy命令</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>pipe.EndPipe(); <span style=color:#75715e>// 在管道结束的位置，将COUNT条命令一次性发送给redis</span>
</span></span><span style=display:flex><span>Console.WriteLine(<span style=color:#e6db74>$&#34;{csredis.Get(&#34;</span>key-one<span style=color:#e6db74>&#34;)}&#34;</span>);
</span></span><span style=display:flex><span>Console.ReadKey();
</span></span></code></pre></div><p>需要特别说明的是，redis中的事务不同于数据库的事务，如果执行命令期间发生错误，redis并不会回滚。</p><h2 id=key的过期>Key的过期</h2><p>redis还允许我们为key设置有效期，当key过期之后，key就不存在了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>redis.Set(<span style=color:#e6db74>&#34;MyKey&#34;</span>, <span style=color:#e6db74>&#34;hello,world&#34;</span>);
</span></span><span style=display:flex><span>Console.WriteLine(redis.Get(<span style=color:#e6db74>&#34;MyKey&#34;</span>)); 
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; &#34;hello,world&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis.Expire(<span style=color:#e6db74>&#34;MyKey&#34;</span>, <span style=color:#ae81ff>5</span>); <span style=color:#75715e>// key在5秒后过期，也可以使用ExpireAt方法让它在指定时间自动过期</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread.Sleep(<span style=color:#ae81ff>6000</span>); <span style=color:#75715e>// 暂停6秒</span>
</span></span><span style=display:flex><span>Console.WriteLine(redis.Get(<span style=color:#e6db74>&#34;MyKey&#34;</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>// output -&gt; &#34;&#34;</span>
</span></span></code></pre></div><h2 id=引用>引用</h2><ul><li><a href=http://doc.redisfans.com/index.html>Redis命令参考</a></li><li><a href=https://item.jd.com/11791607.html>Redis实战</a></li><li><a href=https://redis.io/topics/data-types-intro>An introduction to Redis data types and abstractions</a></li><li><a href=http://www.cnblogs.com/kellynic/p/9803314.html>.NET Core简单且高级的库</a></li><li><a href=https://github.com/ctstone/csredis>Github:CSRedis</a></li></ul></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://xscape.dev/tags/.net>.net</a>
<a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://xscape.dev/tags/redis>redis</a></footer></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>© 2024, xscape_dev</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>